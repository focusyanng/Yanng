<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SourceTree里GitFlow的使用]]></title>
    <url>%2Fbmkpblog%2F2018%2F07%2F16%2FSourceTree%E9%87%8CGitFlow%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[SourceTree里GitFlow的使用这几天看详细了一下Git Flow的模型介绍，感觉“很好很强大”，这个开发模型利用Git的易于分支和合并的特点，能够比较容易地将开发、发布、部署、bug修复分隔开来。 正准备在自己的团队内部推广使用，比较担心的是管理工作稍微繁琐一点。操作倒不复杂，只是需要头脑清醒，熟悉不同分支间的派生、合并关系和时机。没想到“正在瞌睡的时候送来了一个枕头”，正在使用的SourceTree工具天然支持Git Flow，而且把这个模型的各种操作通过菜单命令的形式提供了出来，大大减轻了使用人员的学习使用成本。 为了能让大家少走弯路，也便于我尽快熟练使用，我进行了摸索和实践，下面把具体的使用方式记录下来供参考。 入口 SourceTree界面顶部的工具栏按钮，从右至左第二个“GIT工作流”图标就是。 初始化为了便于展示，我在自己的一个Github项目上进行相关的操作。进入这个项目，然后点击刚刚的“GIT工作流”工具栏按钮。 建议不用做任何改动，直接“确定”即可。SourceTree会自动化进行一些操作，最明显的变化是项目代码库里自动增加了一个develop的分支。 将新创建的develop分支推送到远端仓库。 我们到Github里看这个项目的分支关系图如下： 从此，代码库里就存在了两个永久性的分支：master和develop，未来所有的开发工作都围绕这两个分支进行派生跟合并。派生和合并的时机、源分支、目标分支跟具体的开发类型有关，Gitflow里有明确的规则，如果纯粹使用命令行工具的话，需要牢记这些规则并正确执行。而SourceTree则把这些规则用具体功能自动化实现了，这样就能减少人为的失误，至少在我刚开始手动完成这些操作的时候，失误的几率还是挺高的。 从初始化的第一个界面中，还有三类分支的命名规则：feature、release、hotfix，这就是未来承接具体开发工作的分支类型，从名称中就能准确把握他们的用途。 创建分支上面提到，项目里有两个永久的分支：master和develop。这两个分支也被称为“历史性”分支，在其后的开发工作中，Gitflow模型支持在feature、release、hotfix分支上折腾，这样也有效避免了不同类型的开发工作在代码层级的耦合和干扰。 这三个分支的用途、派生来源分支和合并目标分支如下： feature，功能开发分支，用于承接具体功能需求的开发 派生于develop 合并于develop hotfix，bug修复分支，用于解决线上运行环境发现的bug 派生于master 合并于master、develop release，版本发布分支，用于完成发布准备的 派生于develop 合并于master、develop 跟“历史性”分支相反，这三类分支都是短期分支，针对他们的工作内容完成后，一般都要进行删除。工作内容完成的标识有两个：开发完成、合并完成，缺一不可。 hotfix正式环境正在运行的项目发现了一个bug，需要创建hotfix分支进行bug修复，在已经做过Gitflow初始化的项目上点击工具栏上的“Gitflow”按钮，出现如下窗口： 但有时候我们已经在库里创建了一个还未完成的分支，就会看到这个窗口： 点击“建立新的修复补丁”： 输入自己想要的分支名称，“确定”即可创建，从预览图中可以看到分支派生来源以及派生出来的分支信息。这里有一点要注意，hotfix分支的名称在最终合并到master时会自动变成标签，而一般来说，master的标签往往标识版本号，比如1.0.0，所以这个分值名称最好能够按照版本规则来命名，比如1.0.1。 hotfix分支创建完成后，在分支目录结构里能够看到它： 经过一系列艰苦卓越的工作，这个bug修复完成了，就要合并到master和develop，在SourceTree里，只要通过点击“Gitflow”工具栏即可指导你完成： 点击第一个“完成修复补丁”： 这个操作默认“删除分支”，将把本地的修复分支删除掉，因为它的使命已经完成。合并时如果出现冲突，还是需要开发人员自行解决的。这时能够在“预览”位置看到这个hotfix分支的合并关系示意图。 合并后将代码库推送到远端，这时在Github上可以看到这些分支的关联关系： 中间的蓝色分支既是这个hotfix分支，从图中可以看到这个分支先后被合并到了master和develop上。因为我没有把这个分支提交到Github，所以只有图形示意，没有类似master和develop的名称指示。 feature当接到具体的功能需求时，开发人员需要派生feature分支，在SourceTree上，派生的工作相当简单，只要在已经做过Gitflow初始化的项目上点击工具栏上的“Gitflow”按钮，出现如下窗口： 点击第一个按钮“建立新的功能”： 这里，“功能名称”的值不像hotfix分支那样需要考虑发布版本号的规则，可以用能够清晰描述功能特征的文字。 创建完成后，SourceTree的项目目录树就出现了这个新分支，如下： 现在就可以在这个分支上修修补补了，经过一系列艰苦卓越的工作，这个功能开发完成了，就要合并到develop。功能分支只能合并到develop，为新的release分支做准备， 在SourceTree里，只要通过点击“Gitflow”工具栏即可指导你完成： “删除分支”和“预览”和上面hotfix分支里提到的效果是一样，所不同的是，这里没有“推送变更到远程仓库”的选项。有没有这个选项的差别不大，可能是为了体现分支的推进的紧急程度吧。 合并完成后并将本地库推送到远端Github，这时看Github的分支关系网络图如下： 因为我在做的这个示例操作的时候，并没有再对master分支进行过派生和合并，所以看到master的指示停在原地，后面并入develop的黑色分支既是功能分支。 release所有特性的开发工作都是为了产品功能的更替，当一个或多个特性开发完成，可以进行发布了，就要准备创建release分支。 Release分支是为上线做准备的，它的命名也要遵守项目的版本命名规则，这个名字在最终合并到master时会自动变成版本标签。 这个release分支也是测试工作的目标对象，，经过一系列艰苦卓越的测试、调整工作，这个release完成了，达到了可上线的状态，就要合并到master和develop。 如图“预览”所示，这个release的名称会自动成为master的标签。 这一次，我有意没有删除这个分支，并把它推送到了Github，在Github上的分支关系网络图中，能够明确地看到release的起点和终点，它最终被合并到了两个“历史性”分支中了。 收尾三类临时性分支中，hotfix和release的结果都要合并到master和develop中，为什么？因为它们的修改结果持续影响这后续的开发和维护，必须合并以保证代码的一致性。 至此，SoureTree的Gitflow应用教程已经完成，如果你没有认识到这个特性很有用，我只能说：好吧，你的开发工作还没有复杂到一个程度，一个必须要规避代码干扰、保证并行推进的程度。 对于小型项目和团队来说，基于GIT的中心式协作模型和特性分支模型就足够了；本协作模型适合中型、大型项目和团队；对于更大型的团队和项目来说，除了这个协作模型，还有一个交叉型协作模型可供管理使用。]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DataBinding使用介绍]]></title>
    <url>%2Fbmkpblog%2F2018%2F06%2F27%2FDataBinding%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[DataBinding分享by wuyang 2018/6/20 Google官方发布DataBinding前 MVC开发模式–视图代码与业务逻辑代码耦合严重，重构与复用困难，开发效率低。 MVP开发模式–解耦视图代码与业务逻辑代码，但新增很多接口类和Presenter，可读性降低。 ButterKnife–通过注解访问视图控件 RoboBinding–第三方MVVM方案，现在未持续维护了 发展历程 2015年7月发布的Android Studio v1.3.0 版本上引入 2016年4月Android Studio v2.0.0 上正式支持 支持双向绑定 图示三种开发模式 实际开发中视图代码View和业务逻辑代码Controller都在Activity Fragment，既充当View 又充当Controller,导致代码逻辑复杂 View 与 Model不发生联系，导致Presenter内部的逻辑复杂 与上图逻辑基本一致，最大区别是 View 或ViewModel的变化直接响应给对方 技术优点 官方原生支持 MVVM 模型可以让我们在不改变既有代码框架的前提下，非常容易地使用这些新特性。 去掉Acitivity和Fragments中更新UI数据的代码，让业务逻辑和UI代码分离，整体结构更加清晰。 减少定义view id 和使用findViewById() 数据驱动，UI的展现是依赖于数据的，数据的变化会自然的引发UI的变化 View层和ViewModel逻辑层几乎没有耦合，可以一个人负责Ui 一个人负责数据处理 并行开发 常用操作 构建环境 布局文件 普通数据对象 绑定数据 事件处理 方法调用 监听绑定 关于参数 导入(Imports) 自定义绑定类名 Includes 表达式语言 资源调用 DataBinding数据对象 生成绑定 有Id的View调用 Variables初始化 ViewStubs RecyclerView 重命名属性设置 自定义属性设置 具体操作举例构建环境android { …. dataBinding { enabled = true } } 布局文件12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;data&gt; &lt;!-- 变量user， 描述了一个布局中会用到的属性 --&gt; &lt;variable name="user" type="com.connorlin.databinding.model.User"/&gt; &lt;/data&gt; &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;user.firstName&#125;"/&gt; &lt;!-- 布局文件中的表达式使用 “@&#123;&#125;” 的语法 --&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;user.lastName&#125;"/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 普通数据对象1234567891011121314151617181920212223public class User &#123; private final String mFirstName; private final String mLastName; private int mAge; public User(String firstName, String lastName, int age) &#123; mFirstName = firstName; mLastName = lastName; mAge = age; &#125; public String getFirstName() &#123; return mFirstName; &#125; public String getLastName() &#123; return mLastName; &#125; public int getAge() &#123; return mAge; &#125;&#125; 数据变化可以反映到View上，但是View变化无法反映到对象数据上 绑定数据123456789101112131415161718@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // ActivityBaseBinding 类是自动生成的 ActivityBaseBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_base); User user = new User("Connor", "Lin"); // 所有的 set 方法也是根据布局中 variable 名称生成的 binding.setUser(user);&#125;或者@Overridepublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; ActivityBaseBinding inflate = DataBindingUtil.inflate(inflater, R.layout.activity_base, container, false); return inflate.getRoot();&#125; 事件处理两种实现方式： 方法调用 监听绑定 方法调用12345678910public class EventHandler &#123; private Context mContext; public EventHandler(Context context) &#123; mContext = context; &#125; public void onClickFriend(View view) &#123; Toast.makeText(mContext, "onClickFriend", Toast.LENGTH_LONG).show(); &#125;&#125; 表达式如下： 1234567891011121314151617181920&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;data&gt; &lt;variable name="handler" type="com.connorlin.databinding.handler.EventHandler"/&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:onClick="@&#123;handler::onClickFriend&#125;"/&gt; &lt;!-- 注意：函数名和监听器对象必须对应 --&gt; &lt;!-- 函数调用也可以使用 `.` , 如handler.onClickFriend , 不过已弃用 --&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 监听绑定123public void onTaskClick(Task task) &#123; task.run();&#125; 表达式如下： 123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;layout xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;data&gt; &lt;variable name="handler" type="com.connorlin.databinding.handler.EventHandler"/&gt; &lt;variable name="task" type="com.connorlin.databinding.task.Task"/&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:onClick="@&#123;() -&gt; handler.onTaskClick(task)&#125;"/&gt; &lt;/LinearLayout&gt; &lt;/layout&gt; 关于参数 参数有两种选择：要么不写，要么就要写全。 123456789&lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:onClick="@&#123;() -&gt; handler.onTaskClick(task)&#125;" /&gt;或&lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:onClick="@&#123;(view) -&gt; handler.onTaskClick(task)&#125;"/&gt; lambda 表达式可添加一个或多个参数，同时参数可任意命名 12345public class EventHandler &#123; public void onTaskClickWithParams(View view, Task task) &#123; task.run(); &#125;&#125; 1234&lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:onClick="@&#123;(theview) -&gt; handler.onTaskClickWithParams(theview, task)&#125;" /&gt; 或者 1234567public class EventHandler &#123; public void onCompletedChanged(Task task, boolean completed) &#123; if(completed) &#123; task.run(); &#125; &#125;&#125; 1234&lt;CheckBox android:layout_width="wrap_content" android:layout_height="wrap_content" android:onCheckedChanged="@&#123;(cb, isChecked) -&gt; handler.onCompletedChanged(task, isChecked)&#125;" /&gt; 表达式结果有默认值 null、0、false等等 表达式中可以使用void 1234&lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:onClick="@&#123;(v) -&gt; v.isVisible() ? doSomething() : void&#125;" /&gt; 导入(Imports)12345678&lt;data&gt; &lt;import type="android.view.View"/&gt;&lt;/data&gt;&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:visibility="@&#123;user.isAdult ? View.VISIBLE : View.GONE&#125;"/&gt; 当类名发生冲突时，可以使用 alias 12&lt;import type="android.view.View"/&gt;&lt;import type="com.connorlin.databinding.ui.View" alias="AliasView"/&gt; 导入的类型也可以用于变量的类型引用和表达式中 123456&lt;data&gt; &lt;import type="com.connorlin.databinding.model.User"/&gt; &lt;import type="java.util.List"/&gt; &lt;variable name="user" type="User"/&gt; &lt;variable name="userList" type="List&lt;User&gt;"/&gt;&lt;/data&gt; 导入也可以用于在表达式中使用静态方法 12345678public class MyStringUtils &#123; public static String capitalize(final String word) &#123; if (word.length() &gt; 1) &#123; return String.valueOf(word.charAt(0)).toUpperCase() + word.substring(1); &#125; return word; &#125;&#125; 123456789&lt;data&gt; &lt;import type="com.connorlin.databinding.utils.MyStringUtils"/&gt; &lt;variable name="user" type="com.connorlin.databinding.model.User"/&gt;&lt;/data&gt;…&lt;TextView android:text="@&#123;MyStringUtils.capitalize(user.lastName)&#125;" android:layout_width="wrap_content" android:layout_height="wrap_content"/&gt; java.lang.* 包中的类会被自动导入，可以直接使用，例如， 要定义一个 String 类型的变量 1&lt;variable name="test" type="String" /&gt; 可以在表达式中直接引用带 id 的 view，引用时采用驼峰命名法。 1234567891011&lt;TextView android:id="@+id/first_name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@=&#123;user.firstName&#125;" /&gt;&lt;TextView android:text="@&#123;user.lastName&#125;" android:layout_width="wrap_content" android:layout_height="wrap_content" android:visibility="@&#123;firstName.getVisibility() == View.GONE ? View.GONE : View.VISIBLE&#125;" /&gt; binding 类会生成一个命名为 context 的特殊变量(其实就是 rootView 的 getContext() ) 的返回值)，这个变量可用于表达式中。 如果有名为 context 的变量存在，那么生成的这个 context 特殊变量将被覆盖。 1234&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;handler.loadString(context)&#125;"/&gt; 1234public String loadString(Context context) &#123; // 使用生成的context变量 return context.getResources().getString(R.string.string_from_context);&#125; 自定义绑定类名123&lt;data class="CustomBinding"&gt; ...&lt;/data&gt; 以上会在 databinding 包中生成名为 CustomBinding 的 binding 类。如果需要放置在不同的包下，可以在前面加 “.”： 123&lt;data class=".CustomBinding"&gt; ...&lt;/data&gt; 123&lt;data class="com.example.CustomBinding"&gt; ...&lt;/data&gt; Includes1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:bind="http://schemas.android.com/apk/res-auto"&gt; &lt;data&gt; &lt;variable name="user" type="com.connorlin.databinding.model.User"/&gt; &lt;/data&gt; &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;include layout="@layout/include" app:user="@&#123;user&#125;"/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 需要注意， activity_combine.xml 与 include.xml 中都需要声明 user 变量。 表达式语言1234567891011&lt;!-- 内部使用字符串 &amp; 字符拼接--&gt;&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;`Age :` + String.valueOf(user.age)&#125;"/&gt;&lt;!-- 三目运算--&gt;&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:visibility="@&#123;user.isAdult ? View.VISIBLE : View.GONE&#125;"/&gt; Null合并运算符Null合并运算符 ?? 会在非 null 的时候选择左边的操作，反之选择右边。 1android:text=&quot;@&#123;user.lastName ?? `Default LastName`&#125;&quot; 等同于 1android:text=&quot;@&#123;user.lastName != null ? user.lastName : `Default LastName`&#125;&quot; 容器类通用的容器类：数组，lists，sparse lists，和 maps，可以用 [] 操作符来存取 12345678910111213141516&lt;data&gt; &lt;import type="android.util.SparseArray"/&gt; &lt;import type="java.util.Map"/&gt; &lt;import type="java.util.List"/&gt; &lt;variable name="list" type="List&lt;String&gt;"/&gt; &lt;variable name="sparse" type="SparseArray&lt;String&gt;"/&gt; &lt;variable name="map" type="Map&lt;String, String&gt;"/&gt; &lt;variable name="index" type="int"/&gt; &lt;variable name="key" type="String"/&gt;&lt;/data&gt;…android:text="@&#123;list[index]&#125;"…android:text="@&#123;sparse[index]&#125;"…android:text="@&#123;map[key]&#125;" 字符串常量使用单引号把属性包起来，就可以很简单地在表达式中使用双引号： 1android:text='@&#123;map["firstName"]&#125;' 资源调用也可以在表达式中使用普通的语法来引用资源： 1android:text=&quot;@&#123;@string/fullname(user.fullName)&quot; DataBinding数据对象有三种不同的动态更新数据的机制： Observable 对象 Observable 字段 Observable 容器类 Observable 对象1234567891011121314151617181920212223242526272829public class ObservableContact extends BaseObservable &#123; private String mName; private String mPhone; public ObservableContact(String name, String phone) &#123; mName = name; mPhone = phone; &#125; @Bindable public String getName() &#123; return mName; &#125; public void setName(String name) &#123; mName = name; notifyPropertyChanged(BR.name); &#125; @Bindable public String getPhone() &#123; return mPhone; &#125; public void setPhone(String phone) &#123; mPhone = phone; notifyPropertyChanged(BR.phone); &#125;&#125; ObservableFields123456789public class ObservableFieldContact &#123; public ObservableField&lt;String&gt; mName = new ObservableField&lt;&gt;(); public ObservableField&lt;String&gt; mPhone = new ObservableField&lt;&gt;(); public ObservableFieldContact(String name, String phone) &#123; mName.set(name); mPhone.set(phone); &#125;&#125; 要存取数据，只需要使用 get() / set() 方法： 1234mObservableFieldContact.mName.set("ConnorLin");mObservableFieldContact.mPhone.set("12345678901");String name = mObservableFieldContact.mName.get(); Observable Collections 容器类12345ObservableArrayMap&lt;String, String&gt; mUser = new ObservableArrayMap&lt;&gt;();mUser.put("firstName", "Connor");mUser.put("lastName", "Lin");mUser.put("age", "28");mBinding.setUser(mUser); 在布局中，可以用 String key 来获取 map 中的数据： 12345678910111213141516171819&lt;data&gt; &lt;import type="android.databinding.ObservableMap"/&gt; &lt;variable name="user" type="ObservableMap&amp;lt;String, String&gt;"/&gt;&lt;/data&gt;…&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text='@&#123;user["firstName"]&#125;'/&gt;&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text='@&#123;user["lastName"]&#125;'/&gt;&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text='@&#123;user["age"]&#125;'/&gt; 当 key 是整数类型时，可以使用 ObservableArrayList ： 1234ObservableArrayList&lt;String&gt; user = new ObservableArrayList&lt;&gt;();user.add("Google");user.add("Inc.");user.add("17"); 在布局文件中，使用下标获取列表数据： 12345678910111213141516171819&lt;data&gt; &lt;import type="android.databinding.ObservableList"/&gt; &lt;variable name="user" type="ObservableList&lt;String&gt;"/&gt;&lt;/data&gt;…&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text='@&#123;userList[0]&#125;'/&gt;&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text='@&#123;userList[1]&#125;'/&gt;&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text='@&#123;userList[2]&#125;'/&gt; 生成绑定12ViewDataBinding binding = DataBindingUtil.inflate(LayoutInflater, layoutId, parent, attachToParent);ViewDataBinding binding = DataBindingUtil.bindTo(viewRoot, layoutId); 有ID的View调用布局中每一个带有 ID 的 View，都会生成一个 public final 字段。binding 过程会做一个简单的赋值，在 binding 类中保存对应 ID 的 View。这种机制相比调用 findViewById 效率更高。举个例子： 123456789101112131415161718&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;data&gt; &lt;variable name="user" type="com.connorlin.databinding.model.User"/&gt; &lt;/data&gt; &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;user.firstName&#125;" android:id="@+id/firstName"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;user.lastName&#125;" android:id="@+id/lastName"/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 将会在 binding 类内生成： 12public final TextView firstName;public final TextView lastName; Variables每一个变量会有相应的存取函数： 123456&lt;data&gt; &lt;import type="android.graphics.drawable.Drawable"/&gt; &lt;variable name="user" type="com.connorlin.databinding.model.User"/&gt; &lt;variable name="image" type="Drawable"/&gt; &lt;variable name="note" type="String"/&gt;&lt;/data&gt; 并在 binding 类中生成对应的 getters 和 setters： 123456public com.connorlin.databinding.model.User getUser();public void setUser(com.connorlin.databinding.model.User user);public Drawable getImage();public void setImage(Drawable image);public String getNote();public void setNote(String note); ViewStubsViewStub 相比普通 View 有一些不同。ViewStub 一开始是不可见的，当它们被设置为可见，或者调用 inflate 方法时，ViewStub 会被替换成另外一个布局。 12345678&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;LinearLayout ...&gt; &lt;ViewStub android:id="@+id/view_stub" android:layout="@layout/include" ... /&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 在 Java 代码中获取 binding 实例，为 ViewStubProy 注册 ViewStub.OnInflateListener 事件： 123456789mActivityViewStubBinding = DataBindingUtil.setContentView(this, R.layout.activity_view_stub);mActivityViewStubBinding.viewStub.setOnInflateListener(new ViewStub.OnInflateListener() &#123; @Override public void onInflate(ViewStub stub, View inflated) &#123; IncludeBinding viewStubBinding = DataBindingUtil.bind(inflated); User user = new User("Connor", "Lin", 28); viewStubBinding.setUser(user); &#125;&#125;); 通过 ViewStubProxy 来 inflate ViewStub : 12345public void inflate(View view) &#123; if (!mActivityViewStubBinding.viewStub.isInflated()) &#123; mActivityViewStubBinding.viewStub.getViewStub().inflate(); &#125;&#125; RecyclerViewRecyclerView.Adapter 可以用来处理不同布局，在 onBindViewHolder(VH, int) ) binding 类必须被赋值。 在这种情况下，RecyclerView 的布局内置了一个 item 变量。 BindingHolder 有一个 getBinding 方法，返回一个 ViewDataBinding 基类。 1234public void onBindViewHolder(BindingHolder holder, int position) &#123; holder.getBinding().setVariable(BR.item, mItemList.get(position)); holder.getBinding().executePendingBindings();&#125; 自定义属性设置12345// 无需手动调用此函数@BindingAdapter(&#123;"imageUrl", "error"&#125;)public static void loadImage(ImageView view, String url, Drawable error) &#123; Glide.with(view.getContext()).load(url).error(error).into(view);&#125; 1234&lt;!-- 当url存在时，会自动调用注解方法，即loadImage()--&gt;&lt;ImageView app:imageUrl=“@&#123;url&#125;” app:error=“@&#123;@drawable/ic_launcher&#125;”/&gt; 最佳搭档 Retrofit Lambda Rxjava RxBinding 12]]></content>
      <categories>
        <category>DataBinding</category>
      </categories>
  </entry>
</search>
