<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android的Nexus搭建Maven私有仓库]]></title>
    <url>%2Fbmkpblog%2F2018%2F08%2F15%2FAndroid%E7%9A%84Nexus%E6%90%AD%E5%BB%BAMaven%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Android的Nexus搭建Maven私有仓库Android的Nexus搭建Maven私有仓库 前言 我们平时在开发的时候总会compile一些远程仓库的框架来使用，但不可避免的是有些公司是内网，或是断网了，这就造成了依赖失败，亦或是自己开发了一个很牛的组件，希望同步给小伙伴一块耍耍，但是网络环境不允许，总不能拿个U盘拷贝过去吧，被别人听到程序员是这么协作的，估计会笑掉大牙。 Nexus这个私服正好解决了这个问题，他的思路是本地与远程之间嫁接一层本地的服务器，对于公司内部团队协作开发的，我们可以将自己的组件上传到私服上，同一个局域网下，供小伙伴们依赖，避免了直接与远程仓库对接。 所以，这一次就来教大家如果搭建一个属于自己的本地仓库，然后通过gradle将自己的library上传到自己的仓库，供小伙伴们使用 环境搭建 下载链接:www.sonatype.com/download-os… 我们选择2.X版本的，下载红线指向的zip包 解压看下路径 如果是win系统的话，可以点击bin目录下面的jsw目录，选择自己对应的平台，然后点击start-nexus.bat批处理文件就可以运行起本地的私服，我当前的系统环境mac，只需要在Terminal下cd到bin目录下面，通过命令“./nexus start” 就可以开启私服，当然，与之对应的关闭私服命令是“./nexus stop” 在浏览器中是输入http://localhost:8081/nexus/,点击右上角的log in进行登录，默认的用户名是admin，密码是admin123， 第1处，点击左边的菜单栏的Repositories，可以查看默认的几个仓库 nexus的仓库Type分为以下四种： - group: 仓库组 - hosted：宿主 - proxy：代理 - virtual：虚拟 第3处的链接就是我们仓库的地址，我们后面会根据这个地址，将library上传到该地址的仓库中去 接下来，我们创建一个自己仓库，点击第2处”Add”选择”Hosted Repository”,在新建的面板输入ID和Name，Deployment Policy一定要选择Allow Redeploy，红色箭头那个部分，部署策略设置为允许重新部署，因为我们的库肯定会频繁修改和提交，点击save就可以保存 在仓库列表的中就会出现codelang仓库，我们点击看一下，当前仓库是没有什么文件的 上传文件到仓库 上传到仓库有两种方式，一种是手动方式，一种是通过gradle上传的方式，我们先来看看手动方式 手动方式:我们点击codelang仓库，在仓库详情的tab中，选择Artifact Upload一栏 第1处，我们选择AGV Parameters来定义我们的资源 第2处，设置组Group，何为Group呢？比如，我们依赖Retrofit框架 compile ‘com.squareup.retrofit2:retrofit:2.1.0’ ，那么”com.squareup.retrofit2”就是组，我们在依赖的时候会用到它 第3处，设置Artifact，Artifact和第二处的Group一样，两个冒号中间的”retrofit”就是Artifact，一般，我们用它来定义库的名称 第4处，设置Version版本号，和第二处的例子”2.1.0”一样 第5处，设置包的类型，就是我们依赖的库是什么类型的 第6处，选择我们上传的文件 第7处，将这个库添加到待上传区域，这个地方可以多次选择添加文件，我们将支付宝jar和微信jar一同上传，一般有支付类的app都会有他们俩存在，所以，我们将他两捆绑在一起，以后就只需依赖一个文件就可以了 第8处，我们点击”Upload Artifact”进行上传到仓库 上传成功后，我们点击仓库列表codelang仓库后面的链接，你就会看见我们刚刚定义的库，我们一直点下去看看 对于java web开发，通过pom来依赖Maven库的，我们可以通过仓库详情页的Browser Index 一栏来查看 gradle上传经过上面的一番手动上传，我们应该对上传到仓库有了一定的了解。接下来，我们用gradle的方式，将我们的library库上传到仓库，供我们的小伙伴们集成.(在组件化开发模式下，我们一般都要将业务组件打包成aar文件上传到仓库，供空壳app集成) 1、新建一个Module，选择Android Library，取名叫baseLib，用来存放一些基类 2、第1处，打开项目的gradle.properties文件,第二处，配置上传的参数，供gradle读取 看到这些配置很熟悉吧，和手动上传传递的参数一样 3、接下来，我们打开baseLib的build.gradle文件，配置一下上传到maven的代码，然后gradle运行一下 123456789101112131415161718192021222324252627 dependencies &#123; ... &#125; apply plugin: &apos;maven&apos; uploadArchives &#123; configuration = configurations.archives repositories &#123; mavenDeployer &#123; repository(url: MAVEN_URL) &#123; authentication(userName: NEXUS_USERNAME, password: NEXUS_PASSWORD) &#125; pom.project &#123; groupId GROUP artifactId ARTIFACT version VERSION packaging TYPE description DESCRIPTION &#125; &#125; &#125; &#125; artifacts &#123; archives file(&apos;baselib.aar&apos;) &#125;复制代码 4、我们在baseLib里面写个BaseActivity基类 12345678910111213141516171819202122232425262728293031public abstract class BaseActivity extends Activity &#123; private Toast mToast; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(getLayoutId()); mToast = Toast.makeText(this, &quot;&quot;, Toast.LENGTH_SHORT); mToast.setGravity(Gravity.CENTER, 0, 0); initView(); &#125; public void showToast(String str) &#123; mToast.setText(str); mToast.show(); &#125; /** * 布局id * * @return int */ protected abstract int getLayoutId(); /** * 初始化view */ protected abstract void initView();&#125;复制代码 5、点击build菜单栏下面的ReBuild Project生成aar文件，项目默认是不会生成aar文件的 将项目切换到Project模式下面，就可以看到生成的aar文件 6、点击项目最右边的gradle侧边栏，展开baselib,打开upload，双击运行uploadArchives进行上传，下面没有报错，那就说明上传成功 7、打开远程仓库看看我们的arr文件,和我们手动上传的想效果一样，完美 使用 现在，我们开始使用它吧 我们随便新建一个项目，然后打开项目的build.gradle文件，输入maven的地址，也就是我们codelang仓库的地址 1234567allprojects &#123; repositories &#123; jcenter() maven&#123; url &apos;http://localhost:8081/nexus/content/repositories/codelang&apos;&#125; &#125;&#125;复制代码 然后，我们打开app的build.gradle文件，还记得依赖库的命名方式吗? “Group:Artifact:version” 1234567891011121314dependencies &#123; compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) androidTestCompile(&apos;com.android.support.test.espresso:espresso-core:2.2.2&apos;, &#123; exclude group: &apos;com.android.support&apos;, module: &apos;support-annotations&apos; &#125;) compile &apos;com.android.support:appcompat-v7:26.+&apos; compile &apos;com.android.support.constraint:constraint-layout:1.0.2&apos; testCompile &apos;junit:junit:4.12&apos; //添加依赖库 compile &apos;com.codelang.baseLib:baseLib:1.0.0&apos; compile &apos;codelang:pay:1.0.0&apos;&#125;复制代码 gradle编译一下，然后我们在MainActivity使用一下,完美]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android 内存泄漏案例和解析]]></title>
    <url>%2Fbmkpblog%2F2018%2F07%2F17%2FAndroid-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A1%88%E4%BE%8B%E5%92%8C%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Android 内存泄漏案例和解析Android 编程所使用的 Java 是一门使用垃圾收集器（GC, garbage collection）来自动管理内存的语言，它使得我们不再需要手动调用代码来进行内存回收。那么它是如何判断的呢？简单说，如果一个对象，从它的根节点开始不可达的话，那么这个对象就是没有引用的了，是会被垃圾收集器回收的，其中，所谓的 “根节点” 往往是一个线程，比如主线程。因此，如果一个对象从它的根节点开始是可达的有引用的，但实际上它已经没有再使用了，是无用的，这样的对象就是内存泄漏的对象，它会在内存中占据我们应用程序原本就不是很多的内存，导致程序变慢，甚至内存溢出（OOM）程序崩溃。 内存泄漏的原因并不难理解，但仅管知道它的存在，往往我们还是会不知觉中写出致使内存泄漏的代码。在 Android 编程中，也是有许多情景容易导致内存泄漏，以下将一一列举一些我所知道的内存泄漏案例，从这些例子中应该能更加直观了解怎么导致了内存泄漏，从而在编程过程中去避免。 静态变量造成内存泄漏首先，比较简单的一种情况是，静态变量致使内存泄漏，说到静态变量，我们至少得了解其生命周期才能彻底明白。静态变量的生命周期，起始于类的加载，终止于类的释放。对于 Android 而言，程序也是从一个 main 方法进入，开始了主线程的工作，如果一个类在主线程或旁枝中被使用到，它就会被加载，反过来说，假如一个类存在于我们的项目中，但它从未被我们使用过，算是个孤岛，这时它是没有被加载的。一旦被加载，只有等到我们的 Android 应用进程结束它才会被卸载。 于是，当我们在 Activity 中声明一个静态变量引用了 Activity 自身，就会造成内存泄漏： 12345678public class LeakActivity extends AppCompatActivity &#123; private static Context sContext; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_leak); sContext = this; &#125;&#125; 这样的代码会导致当这个 Activity 结束的时候，sContext 仍然持有它的引用，致使 Activity 无法回收。解决办法就是在这个 Activity 的 onDestroy 时将 sContext 的值置空，或者避免使用静态变量这样的写法。 同样的，如果一个 Activity 的静态 field 变量内部获得了当前 Activity 的引用，比如我们经常会把 this 传给 View 之类的对象，这个对象若是静态的，并且没有在 Activity 生命周期结束之前置空的话，也会导致同样的问题。 非静态内部类和匿名内部类造成内存泄漏也是一个很常见的情景，经常会遇到的 Handler 问题就是这样一种情况，如果我们在 field 声明一个 Handler 变量： 12345private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); &#125;&#125;; 由于在 Java 中，非静态内部类（包括匿名内部类，比如这个 Handler 匿名内部类）会引用外部类对象 this（比如 Activity），而静态的内部类则不会引用外部类对象。所以这里 Handler 会引用 Activity 对象，当它使用了 postDelayed 的时候，如果 Activity 已经 finish 了，而这个 handler 仍然引用着这个 Activity 就会致使内存泄漏，因为这个 handler 会在一段时间内继续被 main Looper 持有，导致引用仍然存在，在这段时间内，如果内存吃紧至超出，就很危险了。 解决办法就是大家都知道的使用静态内部类加 WeakReference： 12345678910private StaticHandler mHandler = new StaticHandler(this);public static class StaticHandler extends Handler &#123; private final WeakReference&lt;Activity&gt; mActivity; public StaticHandler(Activity activity) &#123; mActivity = new WeakReference&lt;Activity&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); &#125;&#125; 另外，综合上面两种情况，如果一个变量，既是静态变量，而且是非静态的内部类对象，那么也会造成内存泄漏： 123456789public class LeakActivity extends AppCompatActivity &#123; private static Hello sHello; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_leak); sHello = new Hello(); &#125; public class Hello &#123;&#125;&#125; 注意，这里我们定义的 Hello 虽然是空的，但它是一个非静态的内部类，所以它必然会持有外部类即 LeakActivity.this 引用，导致 sHello 这个静态变量一直持有这个 Activity，于是结果就和第一个例子一样，Activity 无法被回收。 到这里大家应该可以看出，内存泄漏经常和静态变量有关。和静态变量有关的，还有一种常见情景，就是使用单例模式没有解绑致使内存泄漏，单例模式的对象经常是和我们的应用相同的生命周期，如果我们使用 EventBus 或 Otto 并生成单例，注册了一个 Activity 而没有在页面结束的时候进行解除注册，那么单例会一直持有我们的 Activity，这个 Activity 虽然没有使用了，但会一直占用着内存。 属性动画造成内存泄漏另外当我们使用属性动画，我们需要调用一些方法将动画停止，特别是无限循环的动画，否则也会造成内存泄漏，好在使用 View 动画并不会出现内存泄漏，估计 View 内部有进行释放和停止。 RxJava 使用不当造成内存泄漏最后说一说 RxJava 使用不当造成的内存泄漏，RxJava 是一个非常易用且优雅的异步操作库。对于异步的操作，如果没有及时取消订阅，就会造成内存泄漏： 123456Observable.interval(1, TimeUnit.SECONDS) .subscribe(new Action1&lt;Long&gt;() &#123; @Override public void call(Long aLong) &#123; // pass &#125; &#125;); 同样是匿名内部类造成的引用没法被释放，使得如果在 Activity 中使用就会导致它无法被回收，即使我们的 Action1 看起来什么也没有做。解决办法就是接收 subscribe 返回的 Subscription 对象，在 Activity onDestroy 的时候将其取消订阅即可： 1234567891011121314151617public class LeakActivity extends AppCompatActivity &#123; private Subscription mSubscription; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_leak); mSubscription = Observable.interval(1, TimeUnit.SECONDS) .subscribe(new Action1&lt;Long&gt;() &#123; @Override public void call(Long aLong) &#123; // pass &#125; &#125;); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); mSubscription.unsubscribe(); &#125;&#125; 除了以上这种解决方式之外，还有一种解决方式就是通过 RxJava 的 compose 操作符和 Activity 的生命周期挂钩，我们可以使用一个很方便的第三方库叫做 RxLifecycle 来快捷做到这点，使用起来就像这样： 123456789public class MyActivity extends RxActivity &#123; @Override public void onResume() &#123; super.onResume(); myObservable .compose(bindToLifecycle()) .subscribe(); &#125;&#125; 另外，它还提供了和 View 的便捷绑定，详情可以点击我提供的链接进行了解，这里不多说了。 总结来说，仍然是前面说的内部类或匿名内部类引用了外部类造成了内存泄漏，所以在实际编程过程中，如果涉及此类问题或者线程操作的，应该特别小心，很可能不知不觉中就写出了带内存泄漏的代码了。 内存泄漏的检测前面说了不少内存泄漏的场景和对应的解决办法，但如果我们不知不觉中写出了带有内存泄漏隐患的代码怎么办，面对这个问题，其实到现在，我们是很幸运的，因为有很多相关的检查方式或组件可以选择，比如最简单的：观察 Memory Monitor 内存走势图，可以或多或少知道内存情况，但如果要精确地追踪到内存泄漏点，这里特别推荐伟大的 Square 公司开源的 LeakCanary 方案，LeakCanary 可以做到非常简单方便、低侵入性地捕获内存泄漏代码，甚至很多时候你可以捕捉到 Android 官方组件的内存泄漏代码，具体使用大家可以自行参看其说明，由于本文主要想讲的是内存泄漏的原因和一些常见场景，对于检测，这里就不多说啦 ;)]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SourceTree里GitFlow的使用]]></title>
    <url>%2Fbmkpblog%2F2018%2F07%2F16%2FSourceTree%E9%87%8CGitFlow%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[SourceTree里GitFlow的使用这几天看详细了一下Git Flow的模型介绍，感觉“很好很强大”，这个开发模型利用Git的易于分支和合并的特点，能够比较容易地将开发、发布、部署、bug修复分隔开来。 正准备在自己的团队内部推广使用，比较担心的是管理工作稍微繁琐一点。操作倒不复杂，只是需要头脑清醒，熟悉不同分支间的派生、合并关系和时机。没想到“正在瞌睡的时候送来了一个枕头”，正在使用的SourceTree工具天然支持Git Flow，而且把这个模型的各种操作通过菜单命令的形式提供了出来，大大减轻了使用人员的学习使用成本。 为了能让大家少走弯路，也便于我尽快熟练使用，我进行了摸索和实践，下面把具体的使用方式记录下来供参考。 入口 SourceTree界面顶部的工具栏按钮，从右至左第二个“GIT工作流”图标就是。 初始化为了便于展示，我在自己的一个Github项目上进行相关的操作。进入这个项目，然后点击刚刚的“GIT工作流”工具栏按钮。 建议不用做任何改动，直接“确定”即可。SourceTree会自动化进行一些操作，最明显的变化是项目代码库里自动增加了一个develop的分支。 将新创建的develop分支推送到远端仓库。 我们到Github里看这个项目的分支关系图如下： 从此，代码库里就存在了两个永久性的分支：master和develop，未来所有的开发工作都围绕这两个分支进行派生跟合并。派生和合并的时机、源分支、目标分支跟具体的开发类型有关，Gitflow里有明确的规则，如果纯粹使用命令行工具的话，需要牢记这些规则并正确执行。而SourceTree则把这些规则用具体功能自动化实现了，这样就能减少人为的失误，至少在我刚开始手动完成这些操作的时候，失误的几率还是挺高的。 从初始化的第一个界面中，还有三类分支的命名规则：feature、release、hotfix，这就是未来承接具体开发工作的分支类型，从名称中就能准确把握他们的用途。 创建分支上面提到，项目里有两个永久的分支：master和develop。这两个分支也被称为“历史性”分支，在其后的开发工作中，Gitflow模型支持在feature、release、hotfix分支上折腾，这样也有效避免了不同类型的开发工作在代码层级的耦合和干扰。 这三个分支的用途、派生来源分支和合并目标分支如下： feature，功能开发分支，用于承接具体功能需求的开发 派生于develop 合并于develop hotfix，bug修复分支，用于解决线上运行环境发现的bug 派生于master 合并于master、develop release，版本发布分支，用于完成发布准备的 派生于develop 合并于master、develop 跟“历史性”分支相反，这三类分支都是短期分支，针对他们的工作内容完成后，一般都要进行删除。工作内容完成的标识有两个：开发完成、合并完成，缺一不可。 hotfix正式环境正在运行的项目发现了一个bug，需要创建hotfix分支进行bug修复，在已经做过Gitflow初始化的项目上点击工具栏上的“Gitflow”按钮，出现如下窗口： 但有时候我们已经在库里创建了一个还未完成的分支，就会看到这个窗口： 点击“建立新的修复补丁”： 输入自己想要的分支名称，“确定”即可创建，从预览图中可以看到分支派生来源以及派生出来的分支信息。这里有一点要注意，hotfix分支的名称在最终合并到master时会自动变成标签，而一般来说，master的标签往往标识版本号，比如1.0.0，所以这个分值名称最好能够按照版本规则来命名，比如1.0.1。 hotfix分支创建完成后，在分支目录结构里能够看到它： 经过一系列艰苦卓越的工作，这个bug修复完成了，就要合并到master和develop，在SourceTree里，只要通过点击“Gitflow”工具栏即可指导你完成： 点击第一个“完成修复补丁”： 这个操作默认“删除分支”，将把本地的修复分支删除掉，因为它的使命已经完成。合并时如果出现冲突，还是需要开发人员自行解决的。这时能够在“预览”位置看到这个hotfix分支的合并关系示意图。 合并后将代码库推送到远端，这时在Github上可以看到这些分支的关联关系： 中间的蓝色分支既是这个hotfix分支，从图中可以看到这个分支先后被合并到了master和develop上。因为我没有把这个分支提交到Github，所以只有图形示意，没有类似master和develop的名称指示。 feature当接到具体的功能需求时，开发人员需要派生feature分支，在SourceTree上，派生的工作相当简单，只要在已经做过Gitflow初始化的项目上点击工具栏上的“Gitflow”按钮，出现如下窗口： 点击第一个按钮“建立新的功能”： 这里，“功能名称”的值不像hotfix分支那样需要考虑发布版本号的规则，可以用能够清晰描述功能特征的文字。 创建完成后，SourceTree的项目目录树就出现了这个新分支，如下： 现在就可以在这个分支上修修补补了，经过一系列艰苦卓越的工作，这个功能开发完成了，就要合并到develop。功能分支只能合并到develop，为新的release分支做准备， 在SourceTree里，只要通过点击“Gitflow”工具栏即可指导你完成： “删除分支”和“预览”和上面hotfix分支里提到的效果是一样，所不同的是，这里没有“推送变更到远程仓库”的选项。有没有这个选项的差别不大，可能是为了体现分支的推进的紧急程度吧。 合并完成后并将本地库推送到远端Github，这时看Github的分支关系网络图如下： 因为我在做的这个示例操作的时候，并没有再对master分支进行过派生和合并，所以看到master的指示停在原地，后面并入develop的黑色分支既是功能分支。 release所有特性的开发工作都是为了产品功能的更替，当一个或多个特性开发完成，可以进行发布了，就要准备创建release分支。 Release分支是为上线做准备的，它的命名也要遵守项目的版本命名规则，这个名字在最终合并到master时会自动变成版本标签。 这个release分支也是测试工作的目标对象，，经过一系列艰苦卓越的测试、调整工作，这个release完成了，达到了可上线的状态，就要合并到master和develop。 如图“预览”所示，这个release的名称会自动成为master的标签。 这一次，我有意没有删除这个分支，并把它推送到了Github，在Github上的分支关系网络图中，能够明确地看到release的起点和终点，它最终被合并到了两个“历史性”分支中了。 收尾三类临时性分支中，hotfix和release的结果都要合并到master和develop中，为什么？因为它们的修改结果持续影响这后续的开发和维护，必须合并以保证代码的一致性。 至此，SoureTree的Gitflow应用教程已经完成，如果你没有认识到这个特性很有用，我只能说：好吧，你的开发工作还没有复杂到一个程度，一个必须要规避代码干扰、保证并行推进的程度。 对于小型项目和团队来说，基于GIT的中心式协作模型和特性分支模型就足够了；本协作模型适合中型、大型项目和团队；对于更大型的团队和项目来说，除了这个协作模型，还有一个交叉型协作模型可供管理使用。]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DataBinding使用介绍]]></title>
    <url>%2Fbmkpblog%2F2018%2F06%2F27%2FDataBinding%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[DataBinding分享by wuyang 2018/6/20 Google官方发布DataBinding前 MVC开发模式–视图代码与业务逻辑代码耦合严重，重构与复用困难，开发效率低。 MVP开发模式–解耦视图代码与业务逻辑代码，但新增很多接口类和Presenter，可读性降低。 ButterKnife–通过注解访问视图控件 RoboBinding–第三方MVVM方案，现在未持续维护了 发展历程 2015年7月发布的Android Studio v1.3.0 版本上引入 2016年4月Android Studio v2.0.0 上正式支持 支持双向绑定 图示三种开发模式 实际开发中视图代码View和业务逻辑代码Controller都在Activity Fragment，既充当View 又充当Controller,导致代码逻辑复杂 View 与 Model不发生联系，导致Presenter内部的逻辑复杂 与上图逻辑基本一致，最大区别是 View 或ViewModel的变化直接响应给对方 技术优点 官方原生支持 MVVM 模型可以让我们在不改变既有代码框架的前提下，非常容易地使用这些新特性。 去掉Acitivity和Fragments中更新UI数据的代码，让业务逻辑和UI代码分离，整体结构更加清晰。 减少定义view id 和使用findViewById() 数据驱动，UI的展现是依赖于数据的，数据的变化会自然的引发UI的变化 View层和ViewModel逻辑层几乎没有耦合，可以一个人负责Ui 一个人负责数据处理 并行开发 常用操作 构建环境 布局文件 普通数据对象 绑定数据 事件处理 方法调用 监听绑定 关于参数 导入(Imports) 自定义绑定类名 Includes 表达式语言 资源调用 DataBinding数据对象 生成绑定 有Id的View调用 Variables初始化 ViewStubs RecyclerView 重命名属性设置 自定义属性设置 具体操作举例构建环境android { …. dataBinding { enabled = true } } 布局文件12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;data&gt; &lt;!-- 变量user， 描述了一个布局中会用到的属性 --&gt; &lt;variable name="user" type="com.connorlin.databinding.model.User"/&gt; &lt;/data&gt; &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;user.firstName&#125;"/&gt; &lt;!-- 布局文件中的表达式使用 “@&#123;&#125;” 的语法 --&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;user.lastName&#125;"/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 普通数据对象1234567891011121314151617181920212223public class User &#123; private final String mFirstName; private final String mLastName; private int mAge; public User(String firstName, String lastName, int age) &#123; mFirstName = firstName; mLastName = lastName; mAge = age; &#125; public String getFirstName() &#123; return mFirstName; &#125; public String getLastName() &#123; return mLastName; &#125; public int getAge() &#123; return mAge; &#125;&#125; 数据变化可以反映到View上，但是View变化无法反映到对象数据上 绑定数据123456789101112131415161718@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // ActivityBaseBinding 类是自动生成的 ActivityBaseBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_base); User user = new User("Connor", "Lin"); // 所有的 set 方法也是根据布局中 variable 名称生成的 binding.setUser(user);&#125;或者@Overridepublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; ActivityBaseBinding inflate = DataBindingUtil.inflate(inflater, R.layout.activity_base, container, false); return inflate.getRoot();&#125; 事件处理两种实现方式： 方法调用 监听绑定 方法调用12345678910public class EventHandler &#123; private Context mContext; public EventHandler(Context context) &#123; mContext = context; &#125; public void onClickFriend(View view) &#123; Toast.makeText(mContext, "onClickFriend", Toast.LENGTH_LONG).show(); &#125;&#125; 表达式如下： 1234567891011121314151617181920&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;data&gt; &lt;variable name="handler" type="com.connorlin.databinding.handler.EventHandler"/&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:onClick="@&#123;handler::onClickFriend&#125;"/&gt; &lt;!-- 注意：函数名和监听器对象必须对应 --&gt; &lt;!-- 函数调用也可以使用 `.` , 如handler.onClickFriend , 不过已弃用 --&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 监听绑定123public void onTaskClick(Task task) &#123; task.run();&#125; 表达式如下： 123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;layout xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;data&gt; &lt;variable name="handler" type="com.connorlin.databinding.handler.EventHandler"/&gt; &lt;variable name="task" type="com.connorlin.databinding.task.Task"/&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:onClick="@&#123;() -&gt; handler.onTaskClick(task)&#125;"/&gt; &lt;/LinearLayout&gt; &lt;/layout&gt; 关于参数 参数有两种选择：要么不写，要么就要写全。 123456789&lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:onClick="@&#123;() -&gt; handler.onTaskClick(task)&#125;" /&gt;或&lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:onClick="@&#123;(view) -&gt; handler.onTaskClick(task)&#125;"/&gt; lambda 表达式可添加一个或多个参数，同时参数可任意命名 12345public class EventHandler &#123; public void onTaskClickWithParams(View view, Task task) &#123; task.run(); &#125;&#125; 1234&lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:onClick="@&#123;(theview) -&gt; handler.onTaskClickWithParams(theview, task)&#125;" /&gt; 或者 1234567public class EventHandler &#123; public void onCompletedChanged(Task task, boolean completed) &#123; if(completed) &#123; task.run(); &#125; &#125;&#125; 1234&lt;CheckBox android:layout_width="wrap_content" android:layout_height="wrap_content" android:onCheckedChanged="@&#123;(cb, isChecked) -&gt; handler.onCompletedChanged(task, isChecked)&#125;" /&gt; 表达式结果有默认值 null、0、false等等 表达式中可以使用void 1234&lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:onClick="@&#123;(v) -&gt; v.isVisible() ? doSomething() : void&#125;" /&gt; 导入(Imports)12345678&lt;data&gt; &lt;import type="android.view.View"/&gt;&lt;/data&gt;&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:visibility="@&#123;user.isAdult ? View.VISIBLE : View.GONE&#125;"/&gt; 当类名发生冲突时，可以使用 alias 12&lt;import type="android.view.View"/&gt;&lt;import type="com.connorlin.databinding.ui.View" alias="AliasView"/&gt; 导入的类型也可以用于变量的类型引用和表达式中 123456&lt;data&gt; &lt;import type="com.connorlin.databinding.model.User"/&gt; &lt;import type="java.util.List"/&gt; &lt;variable name="user" type="User"/&gt; &lt;variable name="userList" type="List&lt;User&gt;"/&gt;&lt;/data&gt; 导入也可以用于在表达式中使用静态方法 12345678public class MyStringUtils &#123; public static String capitalize(final String word) &#123; if (word.length() &gt; 1) &#123; return String.valueOf(word.charAt(0)).toUpperCase() + word.substring(1); &#125; return word; &#125;&#125; 123456789&lt;data&gt; &lt;import type="com.connorlin.databinding.utils.MyStringUtils"/&gt; &lt;variable name="user" type="com.connorlin.databinding.model.User"/&gt;&lt;/data&gt;…&lt;TextView android:text="@&#123;MyStringUtils.capitalize(user.lastName)&#125;" android:layout_width="wrap_content" android:layout_height="wrap_content"/&gt; java.lang.* 包中的类会被自动导入，可以直接使用，例如， 要定义一个 String 类型的变量 1&lt;variable name="test" type="String" /&gt; 可以在表达式中直接引用带 id 的 view，引用时采用驼峰命名法。 1234567891011&lt;TextView android:id="@+id/first_name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@=&#123;user.firstName&#125;" /&gt;&lt;TextView android:text="@&#123;user.lastName&#125;" android:layout_width="wrap_content" android:layout_height="wrap_content" android:visibility="@&#123;firstName.getVisibility() == View.GONE ? View.GONE : View.VISIBLE&#125;" /&gt; binding 类会生成一个命名为 context 的特殊变量(其实就是 rootView 的 getContext() ) 的返回值)，这个变量可用于表达式中。 如果有名为 context 的变量存在，那么生成的这个 context 特殊变量将被覆盖。 1234&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;handler.loadString(context)&#125;"/&gt; 1234public String loadString(Context context) &#123; // 使用生成的context变量 return context.getResources().getString(R.string.string_from_context);&#125; 自定义绑定类名123&lt;data class="CustomBinding"&gt; ...&lt;/data&gt; 以上会在 databinding 包中生成名为 CustomBinding 的 binding 类。如果需要放置在不同的包下，可以在前面加 “.”： 123&lt;data class=".CustomBinding"&gt; ...&lt;/data&gt; 123&lt;data class="com.example.CustomBinding"&gt; ...&lt;/data&gt; Includes1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:bind="http://schemas.android.com/apk/res-auto"&gt; &lt;data&gt; &lt;variable name="user" type="com.connorlin.databinding.model.User"/&gt; &lt;/data&gt; &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;include layout="@layout/include" app:user="@&#123;user&#125;"/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 需要注意， activity_combine.xml 与 include.xml 中都需要声明 user 变量。 表达式语言1234567891011&lt;!-- 内部使用字符串 &amp; 字符拼接--&gt;&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;`Age :` + String.valueOf(user.age)&#125;"/&gt;&lt;!-- 三目运算--&gt;&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:visibility="@&#123;user.isAdult ? View.VISIBLE : View.GONE&#125;"/&gt; Null合并运算符Null合并运算符 ?? 会在非 null 的时候选择左边的操作，反之选择右边。 1android:text=&quot;@&#123;user.lastName ?? `Default LastName`&#125;&quot; 等同于 1android:text=&quot;@&#123;user.lastName != null ? user.lastName : `Default LastName`&#125;&quot; 容器类通用的容器类：数组，lists，sparse lists，和 maps，可以用 [] 操作符来存取 12345678910111213141516&lt;data&gt; &lt;import type="android.util.SparseArray"/&gt; &lt;import type="java.util.Map"/&gt; &lt;import type="java.util.List"/&gt; &lt;variable name="list" type="List&lt;String&gt;"/&gt; &lt;variable name="sparse" type="SparseArray&lt;String&gt;"/&gt; &lt;variable name="map" type="Map&lt;String, String&gt;"/&gt; &lt;variable name="index" type="int"/&gt; &lt;variable name="key" type="String"/&gt;&lt;/data&gt;…android:text="@&#123;list[index]&#125;"…android:text="@&#123;sparse[index]&#125;"…android:text="@&#123;map[key]&#125;" 字符串常量使用单引号把属性包起来，就可以很简单地在表达式中使用双引号： 1android:text='@&#123;map["firstName"]&#125;' 资源调用也可以在表达式中使用普通的语法来引用资源： 1android:text=&quot;@&#123;@string/fullname(user.fullName)&quot; DataBinding数据对象有三种不同的动态更新数据的机制： Observable 对象 Observable 字段 Observable 容器类 Observable 对象1234567891011121314151617181920212223242526272829public class ObservableContact extends BaseObservable &#123; private String mName; private String mPhone; public ObservableContact(String name, String phone) &#123; mName = name; mPhone = phone; &#125; @Bindable public String getName() &#123; return mName; &#125; public void setName(String name) &#123; mName = name; notifyPropertyChanged(BR.name); &#125; @Bindable public String getPhone() &#123; return mPhone; &#125; public void setPhone(String phone) &#123; mPhone = phone; notifyPropertyChanged(BR.phone); &#125;&#125; ObservableFields123456789public class ObservableFieldContact &#123; public ObservableField&lt;String&gt; mName = new ObservableField&lt;&gt;(); public ObservableField&lt;String&gt; mPhone = new ObservableField&lt;&gt;(); public ObservableFieldContact(String name, String phone) &#123; mName.set(name); mPhone.set(phone); &#125;&#125; 要存取数据，只需要使用 get() / set() 方法： 1234mObservableFieldContact.mName.set("ConnorLin");mObservableFieldContact.mPhone.set("12345678901");String name = mObservableFieldContact.mName.get(); Observable Collections 容器类12345ObservableArrayMap&lt;String, String&gt; mUser = new ObservableArrayMap&lt;&gt;();mUser.put("firstName", "Connor");mUser.put("lastName", "Lin");mUser.put("age", "28");mBinding.setUser(mUser); 在布局中，可以用 String key 来获取 map 中的数据： 12345678910111213141516171819&lt;data&gt; &lt;import type="android.databinding.ObservableMap"/&gt; &lt;variable name="user" type="ObservableMap&amp;lt;String, String&gt;"/&gt;&lt;/data&gt;…&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text='@&#123;user["firstName"]&#125;'/&gt;&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text='@&#123;user["lastName"]&#125;'/&gt;&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text='@&#123;user["age"]&#125;'/&gt; 当 key 是整数类型时，可以使用 ObservableArrayList ： 1234ObservableArrayList&lt;String&gt; user = new ObservableArrayList&lt;&gt;();user.add("Google");user.add("Inc.");user.add("17"); 在布局文件中，使用下标获取列表数据： 12345678910111213141516171819&lt;data&gt; &lt;import type="android.databinding.ObservableList"/&gt; &lt;variable name="user" type="ObservableList&lt;String&gt;"/&gt;&lt;/data&gt;…&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text='@&#123;userList[0]&#125;'/&gt;&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text='@&#123;userList[1]&#125;'/&gt;&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text='@&#123;userList[2]&#125;'/&gt; 生成绑定12ViewDataBinding binding = DataBindingUtil.inflate(LayoutInflater, layoutId, parent, attachToParent);ViewDataBinding binding = DataBindingUtil.bindTo(viewRoot, layoutId); 有ID的View调用布局中每一个带有 ID 的 View，都会生成一个 public final 字段。binding 过程会做一个简单的赋值，在 binding 类中保存对应 ID 的 View。这种机制相比调用 findViewById 效率更高。举个例子： 123456789101112131415161718&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;data&gt; &lt;variable name="user" type="com.connorlin.databinding.model.User"/&gt; &lt;/data&gt; &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;user.firstName&#125;" android:id="@+id/firstName"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;user.lastName&#125;" android:id="@+id/lastName"/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 将会在 binding 类内生成： 12public final TextView firstName;public final TextView lastName; Variables每一个变量会有相应的存取函数： 123456&lt;data&gt; &lt;import type="android.graphics.drawable.Drawable"/&gt; &lt;variable name="user" type="com.connorlin.databinding.model.User"/&gt; &lt;variable name="image" type="Drawable"/&gt; &lt;variable name="note" type="String"/&gt;&lt;/data&gt; 并在 binding 类中生成对应的 getters 和 setters： 123456public com.connorlin.databinding.model.User getUser();public void setUser(com.connorlin.databinding.model.User user);public Drawable getImage();public void setImage(Drawable image);public String getNote();public void setNote(String note); ViewStubsViewStub 相比普通 View 有一些不同。ViewStub 一开始是不可见的，当它们被设置为可见，或者调用 inflate 方法时，ViewStub 会被替换成另外一个布局。 12345678&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;LinearLayout ...&gt; &lt;ViewStub android:id="@+id/view_stub" android:layout="@layout/include" ... /&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 在 Java 代码中获取 binding 实例，为 ViewStubProy 注册 ViewStub.OnInflateListener 事件： 123456789mActivityViewStubBinding = DataBindingUtil.setContentView(this, R.layout.activity_view_stub);mActivityViewStubBinding.viewStub.setOnInflateListener(new ViewStub.OnInflateListener() &#123; @Override public void onInflate(ViewStub stub, View inflated) &#123; IncludeBinding viewStubBinding = DataBindingUtil.bind(inflated); User user = new User("Connor", "Lin", 28); viewStubBinding.setUser(user); &#125;&#125;); 通过 ViewStubProxy 来 inflate ViewStub : 12345public void inflate(View view) &#123; if (!mActivityViewStubBinding.viewStub.isInflated()) &#123; mActivityViewStubBinding.viewStub.getViewStub().inflate(); &#125;&#125; RecyclerViewRecyclerView.Adapter 可以用来处理不同布局，在 onBindViewHolder(VH, int) ) binding 类必须被赋值。 在这种情况下，RecyclerView 的布局内置了一个 item 变量。 BindingHolder 有一个 getBinding 方法，返回一个 ViewDataBinding 基类。 1234public void onBindViewHolder(BindingHolder holder, int position) &#123; holder.getBinding().setVariable(BR.item, mItemList.get(position)); holder.getBinding().executePendingBindings();&#125; 自定义属性设置12345// 无需手动调用此函数@BindingAdapter(&#123;"imageUrl", "error"&#125;)public static void loadImage(ImageView view, String url, Drawable error) &#123; Glide.with(view.getContext()).load(url).error(error).into(view);&#125; 1234&lt;!-- 当url存在时，会自动调用注解方法，即loadImage()--&gt;&lt;ImageView app:imageUrl=“@&#123;url&#125;” app:error=“@&#123;@drawable/ic_launcher&#125;”/&gt; 最佳搭档 Retrofit Lambda Rxjava RxBinding 12]]></content>
      <categories>
        <category>DataBinding</category>
      </categories>
  </entry>
</search>
